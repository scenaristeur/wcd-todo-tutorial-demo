
По условию задания вы должны создать ToDo приложение из уже готовых React компонентов и функций. 
Если вы когда-либо создавали приложение с React компонентами, тогда вам должно быть понятно что такое React компонент. 
А вот с понятием "готовая функция" мы должны разобраться, но мы это сделаем немного позднее.

> Если вы уже что-то делали или создавали в этом проекте до того как начали читать эту статью, тогда перезагрузите всю страницу в браузере и выберите "Reset to default demo" опцию после перезагрузки. 

В левой стороне экрана вы можете видеть панель ресурсов, которые доступны на начальном этапе и разбиты на секции.
Судя по числам в заголовках секций, у вас есть 11 компонентов, 13 функций, и один шаблон в секции "Templates". 

Давайте ознакомимся для начала с компонентами.
Откройте секцию "Components". Внутри вы можете увидеть каталоги с компонентами.

Каталоги названы так, чтобы можно было легко найти нужный компонент, который имеет определенное назначение в проекте.
Например, в этом проекте есть три группы:
* atom - это простые компоненты типа кнопок и иконок;
* layout - это компоненты, которые отвечают за разметку и расположение компонентов на странице;
* todo - это компоненты, которые специально сделаны для приложения ToDo.

В Webcodesk можно посмотреть как выглядит каждый компонент по отдельности (типа как в знаменитом Storybook). 
Раскройте любой каталог и просто кликните на название какого-либо комопнента.
Перед вами должна появится закладка в центральной области экрана, где вы увидите как выглядит компонент вживую.
 
Тут вы можете поиграть с компонентом - изменить его свойства, покликать и увидеть какие события при этом происходят.
Кроме того, тут же можно прочитать спецификацию компонента, где описаны его свойства и для чего он предназначен.
Это круто, потому что вы не знаете на данном этапе что за компоненты и как их можно использовать в приложении. 

А теперь посмотрим на секцию "Functions". В этой секции есть такие же каталоги, как и в секции "Components". 
Если вы раскроете каталог, то вы заметите, что внутри находятся названия наборов функций, которые совпадают с названиями компонентов. 
Это значит, что в наборах находятся функции как-то связаные с компонентами - мы это обсудим во время выполнения задания позднее.

Если кликнуть на название набора функций, то в новой закладке можно будет прочитать спецификацию всех функций, которые входят в данный набор.

Вам повезло - разработчики компонентов дали вам инструкцию по сборке приложения чтобы сэкономить время, 
поэтому у вас нет необходимости знакомиться с каждым комопонентом и придумывать в какой последовательности собирать приложение. 
Но в реальном проекте вам надо было бы изучить спецификацию каждого компонента и функции, чтобы потом начать собирать приложение.   

Итак, давайте начнем сборку в соответствии с инструкцией.

Первым делом необходимо создать страницу с названием "main", которая будет служить начальной станицей нашего приложения.

> Страница с названием "main" в Webcodesk проектах используется как домашняя страница и будет доступна по двум адресам: `/` `/main`

Кликните на кнопку с иконкой "плюс" следующую за названием секции "Pages".

(имаж)

Введите имя страницы `main` и нажмите кнопку `Create` в диалоге.

(имаж)

Перед вами должна открыться новая закладка - это редактор страницы `main`.

> Если в центре страницы вы не видите иконки "круг с плюсом", то найдите кнопку `Reload` в верхней панели и нажмите ее чтобы перезагрузить страницу.

Теперь с помощью мышки перетащите компонент `PageFrameWithActionButton` из секции "Components" 
на пустую область в центре страницы и отпустите его там.

После этого на странице ничего визуально не изменится. 
Поэтому что-бы проверить результат действия нажмите на кнопку `Structure` в top toolbar. 
Таким образом вы откроете левую панель в редакторе страницы, 
где вы увидите из каких компонентов складывается страница на данный момент.

(имаж) 

В структуре страницы видно, что корневым компонентом станицы является какой-то `pageFrameWithActionButton`. 
Это имя в точности совпадает с названием компонента, который мы перетянули. 
Но непонятно почему это имя начинается с маленькой буквы.
  
Тут надо немного остановиться и понять, откуда взялось это название.

Дело в том, что мы можем использовать много копий компонентов на страницах приложения. 
Каждая такая копия может иметь различные значения в свойствах. 
Это и делает компонентный подход таким популярным в разработке - 
мы можем переиспользовать одни и те же компоненты но с разными настройками в его свойствах.

Разные копии компонентов на страницах должны иметь уникальные имена. 
Если же вы захотите использовать одинаковые копии компонента в разных местах страницы или вообще на другой странице, 
тогда необходимо просто задать идентичное имя этим копиям компонента.

Webcodesk автоматически создал имя новой копии компонента. 
Если вы не поменяете это имя, 
то при создании новой копии мы можем случайно переписать значения свойств предыдущей копии с таким же названием.

Поэтому вам необходимо изменить имя копии `pageFrameWithActionButton`.  
Найдите поле `Instance name` на панели свойств в правой стороне экрана и измените название на `mainPageFrame`.

(имаж)

Теперь нажмите кнопку `Save` на top toolbar - таким образом мы сохраним наши изменения на всякий случай. 

> Webcodesk сохраняет все измененения в редакторе страницы автоматически если перейти на другую закладку.

Откройте панель со структурой страницы. Вы увидите несколько областей обрамленных прерывистой линией. 
Это области, в которые вы можете поместить другие компоненты.
Каждая такая область соответсвует какому-либо свойству с типом `Element` или `Node` в копии компонента.

> Читайте в User Guide (линк) о возможных типах свойств в компонентах

(имаж)
 
Хотя, конечно, лучше сначала прочитать в описании свойства какой компонент предполагается туда вставлять.

> Если вы наведете курсор на название свойства на панели свойств, то вы ивидите всплывающую подсказку о свойстве.

Но у вас нет времени на это, зато есть эта инструкция.

Поэтому перетяните компонент `NavigationTabs` в область `Application Bar Content`, которая находится в копии `mainPageFrame`.
Выделите вновь созданную копию (кликните на ней) `navigationTabs` и переименуйте ее на `mainPageNavigationTabs`.

(имаж)  

Вы видите, что задний фон вашего заголовка имеет темный цвет и поэтому сливается с текстом кнопок в копии `mainPageNavigationTabs`.
Поэтому нам необходимо изменить цвет заголовка в компоненте `mainPageFrame`.

Выделите `mainPageFrame` и найдите на панели свойств группу свойств "Application Bar Palette". Раскройте группу кликнув на нее.
Затем раскройте внутреннюю группу "Background Color". 
Теперь выберите название цвета "white" из выпадающего списка в свойстве "Color Hue".

(имаж)

Вы можете увидеть, что фон центрально области на странице немного отличается от фона заголовка страницы. 
Поэтому вы должны поменять фон страницы на цвет "white" тоже.

При выделенном `mainPageFrame` найдите свойство "Color Hue" в группе "Main Area Palette -> Background Color" и установите значение в "white". 

> Этот проект использует Material UI библиотеку для своих компонентов, поэтому большинство свойств используют терминологию MUI компонентов. 

Чтобы посмотреть как будет выглядеть и работать ваша страница в браузере вживую, перейдите на закладку "Live Preview".

Если вы покликаете по кнопкам навигации вверху страницы, то вы заметите, что кнопки не активируются при клике на них.
Давайте вы попробуете оживить их. 

Вам необходимо создать flow диаграмму в которой будет описано поведение навигации. 
В проектах Webcodesk flow диаграммы используются для описания последовательности действий, 
которая происходит при возникновении какого-то события.

Например, на данном этапе нам необходимо описать что будет происходить при клике на кнопке навигации. 

Кликните на кнопке с иконкой "плюс" рядом с названием секции "Flows".

(имаж)    

Компонент `NavigationTabs` сделан специально для ToDo приложения, и в его спецификации написано, 
что его необходимо использовать для фильтрации ToDo записей.
Поэтому назовите flow именем `change-navigation-filter-by-click`.

> Давайте такое имя flow, которое будет ясно говорить о том, что в нем происходит. Таким образом в дальнейшем мы сможем быстро понять где находится необходимая логика поведения приложения.

Перед вами откроется закладка с новой flow диаграммой. 
Если вас не устраивает положение диаграммы на экране, 
вы можете передвинуть весь рисунок с помощью мышки - зажмите левую кнопку мыши и потяните курсор в нужном направлении.

(имаж)

Теперь найдите копию `mainPageNavigationTabs` на панели слева в секции "Pages" и раскрыв ветку страницы `main` в дереве ресурсов.

Перетащите мышкой название копии `mainPageNavigationTabs` прямо на элемент диаграммы `Application`. 
Элемент `Application` будет автоматически заменен на элемент копии `mainPageNavigationTabs`.

(имаж)
   
Как вы видите, на рисунке элемента копии изображены точки. 
Точка слева обозначает вход данных, а точки справа обозначают выходы данных.

Все копии компонентов имеют один вход - "props", который обозначает все свойства компонента кроме тех, которые имеют тип функций. 
Выходов же в компоненте может быть несколько. 
Каждый из выходов будет соответствовать свойству компонента с типом функция, то есть какому-то событию в компоненте.

В данном случае, вы видите два выхода и поэтому в навигации могут случиться два события: `onActiveTabUpdated` и `onChangeActiveTab`. 
Как сказано в спецификации, событие `onChangeActiveTab` возникает в случае когда пользователь кликает на кнопку навигации.
Вы можете использовать это событие, чтобы сделать активной кнопку при клике на ней.

Но давайте сначала найдем как же компонент навигации отображает какая кнопка будет активна в определенный момент времени.

Если снова переключиться на закладку редактора `main` страницы и выбрать копию (кликнуть по ней) `mainPageNavigationTabs`, 
то в свойствах мы можем найти свойство `Active Tab Type`. 
Если установить другое значение в этом свойстве, то можно увидеть, что активная кнопка поменялась на другую.

(имаж)

Из этого очевидно, что для переключения активной кнопки по событию `onChangeActiveTab` необходимо поменять свойство `Active Tab Type`.
Это надо как-то описать в вашем `change-navigation-filter-by-click` flow.

За изменение свойств в копиях компонентов отвечают соответствующие функции. 
В данном проекте, такие функции включены в наборы функций с названиями идентичными именам компонентов, 
свойства которых они могут менять.

Переключитесь на закладку `change-navigation-filter-by-click` flow, 
найдите функцию `setActiveNavigationTab` в дереве ресурсов "Functions" -> "todo" -> "NavigationTabs", 
и перетащите название функции на любое свободное пространство на flow диаграмме.

(имаж)

По аналогии с копиями компонентов, каждая функция имеет один вход и может иметь несколько выходов на flow диаграмме. 

Теперь вам нужно соединить выход `onChangeActiveTab` в копии `mainPageNavigationTabs` с входом `callFunction` в функции `setActiveNavigationTab`.

> Наведите курсор мышки на точку выхода `onChangeActiveTab`, 
нажмите левую кнопку мыши и перетащите появившуюся стрелочку до точки входа `callFunction` и отпустите левую кнопку мыши.
> Если вы ошиблись и соединили не те вход и выход, 
> тогда просто повторите действие с нужными выходом и входом, тогда связь автоматически обновится.

(имаж)

Теперь функция `setActiveNavigationTab` будет срабатывать на нажатие кнопки в навигации. 
Но все равно, на странице ничего не будет происходить, потому что результат выполнения функции не передается в свойства копии компонента.

Чтобы это исправить это, перетащите название той же копии `mainPageNavigationTabs` из ветки "Pages" -> "main" куда-нибудь на flow диаграмму.
Соедините выход `navigationTabsProps` функции `setActiveNavigationTab` с входом `props` в новом элементе копии `mainPageNavigationTabs`.

(имаж)

Теперь можно смело переключаться на закладку "Live Preview" и проверить результат выполнения flow.

Ну что же, если все работает как задуманно, вы можете продолжить дополнять композицию главной страницы.

Переключитесь на закладку редактора страницы `main`, или если она закрыта, 
откройте ее кликнув на название страницы в секции "Pages".
Откройте панель `Structure` в редакторе страницы, 
и перетащите название компонента `Container` из ветки "Components" -> "layout" 
в свободную область `0 item` в группе `Main Area Children` в структуре страницы.
Переименуйте копию `container` на `mainPageContainer`.

(имаж)

Вы наверное заметили, что некоторые свойства имеют названия типа `0 item`, `1 item`, и т.д. 
Например, это видно в свойстве `Tabs` в копии `mainPageNavigationTabs`. 
Это означает, что свойство `Tabs` имеет тип массив и может содержать несколько похожих свойств или груп свойств.

> Более детально о типах свойств в компонентах почитайте в User Guide (линк). 

(имаж)

Сейчас же достаточно понимать, что вы можете увеличивать количество items в массиве или удалять из массива item прямо в панели свойств.

(имаж)

Копия `mainPageFrame` содержит один item в массиве `Main Area Children` и этого сейчас достаточно для контейнера, 
в который мы будем добавлять другие копии компонентов.

Сейчас вам нужно немного подвинуть контейнер вниз, 
потому что он перекрывается верхней областью страницы, где находится навигация.

(имаж)

Поэтому найдите группу свойств `Main Area Padding` в копии `mainPageFrame`. 
Раскройте ее и измените значения свойства `Padding Top` на значение `100px`.

(имаж) 

Выберите копию `mainPageContainer` в структуре страницы и измените свойство `Max Width` на `sm`.

(имаж)

Найдите `Grid` компонент в дереве ресурсов слева и перетащите название на пустую область внутри `mainPageContainer` на странице, 
либо на `Content` область в дереве структуры страницы. И сразу же переименуйте экземпляр на `mainPageGrid`.

(имаж)

Свойство `Cells` копии `mainPageGrid` содержит 3 items по молчанию. 
Вам нужно всего две ячейки в таблице - одна для заголовка и одна для списка DoTo записей.

Поэтому раскройте массив `Cells` и удалите один item из массива нажав на кнопку `Delete` около названия поля свойства.

(имаж)

Теперь раскройте группу `Grid` в свойствах `mainPageGrid`, и установите значение `Spacing` в 3.

(имаж)

Перетяните компонент `Typography` из "Components" -> "atom" на первую ячейку `mainPageGrid`. 
Переименуйте копию на `mainPageLabel`. 
Установите следующие значения свойств:
* `Align`: `center`
* `Variant`: `h5`
* `Text`: "ToDos"  

(имаж)

Поместите компонент `Paper` из "Components" -> "layout" во вторую ячейку `mainPageGrid`.
Переименуйте копию компонента на `mainPagePaper` и установите следующие свойства:
* `Elevation`: 2
* `Palette` -> `Background Color` -> `Color Hue`: "blue"
* `Palette` -> `Color` -> `Color Hue`: "white"

(имаж)

Перетяните компонент `ToDoNotesList` из "Components" -> "todo" в `0 item` в массиве `Children` под копией `mainPagePaper`.
Переименуйте новую копию на `mainPageNotesList`.

(имаж)

Теперь добавим кнопку, для создания новых записей в списке ToDo. 
Перетащите компонент `Action Button` в свободную область `Action Button Content` внутри копии `mainPageFrame` - найдите ее в деревер структуры страницы.
Переименуйте копию кнопки на `mainPageActionButton` и установите такие свойства:
* `Color`: "primary"
* `Size`: "large"

(имаж)

Вашей кнопке не хватает иконки плюс. За иконки в проекте отвечает компонент `SvgIcon`, который отображает SVG рисунки в виде иконок.
Для экономии времени, у вас уже есть заготовка иконки "плюс" в секции "Templates" и каталоге "icons" - `add-icon`. 
Там вы найдете копию компонента `SvgIcon` с предустановленным значением свойства `Path`.
Поэтому просто перетяните название `add-icon` из секции "Templates" на свободную область `Icon` под копией `mainPageActionButton` в дереве структуры страницы.
И не переименовывайте название новой копии.

(имаж)

Вот так должна выглядеть страница "main" на просмотре. 

(имаж)

Далее вам необходимо создать вторую страницу приложения, где пользователь сможет писать текст новой записи ToDo.
Создайте новую страницу в секции "Pages" и назовите ее `new-note`.

(имаж)

Сейчас в быстром режиме создадим композицию на странице.

Перейдите на закладку редактора страницы `main`.
Выберите копию `mainPageFrame` в редакторе. 
Скопируйте ее в буфер обмена нажав комбинацию клавиш `Ctrl + C` / `Command + C`, или кликните на кнопку копирования в буффер на top toolbar.

Теперь перейдите на закладку редактора страницы `new-note`. 
Выберите пустую область в корне дерева структуры страницы и нажмите комбинацию клавиш вставки из буффера обмена: `Ctrl + V` / `Command + V`.

(имаж)

Выберите `mainPageActionButton` копию и удалите ее нажав клавишу `Delete` или кнопку `Delete` на top toolbar.
То же самое сделайте с копиями `mainPageNavigationTabs` и `mainPageNotesList`.

(имаж)

Теперь необходимо переименовать следующие копии компонентов на странице `new-note`:
* `mainPageFrame` переименовать на `newNotePageFrame`
* `mainPageContainer` переименовать на `newNotePageContainer`
* `mainPageGrid` переименовать на `newNotePageGrid`
* `mainPageLabel` переименовать на `newNotePageLabel`
* `mainPagePaper` переименовать на `newNotePagePaper`

Установите значение "New ToDo" в свойстве `Text` в экземпляре `newNotePageLabel`.

Установите следующие свойства в копии `newNotePagePaper`:
* `Elevation`: 2
* `Padding Spacing` -> `Padding Left`: 2
* `Padding Spacing` -> `Padding Right`: 2
* `Padding Spacing` -> `Padding Bottom`: 2
* `Palette` -> `Background Color` -> `Color Hue`: "yellow"
* `Palette` -> `Background Color` -> `Color Shade`: 100

Поместите компонент `NewNoteForm` в область `Children` -> `0 item` экземпляра `newNotePagePaper` в структуре дерева страницы. 
Переименуйте его экземпляр на `newNotePageForm`.

(имаж)

Пока на страницах не работает ничего кроме переключения активной кнопки в навигации.

Сначала вам необходимо сделать так, чтобы при клике на кнопку `mainPageActionButton` на странице `main`, 
пользователь переходил на страницу `new-note`.


Создайте новый flow с названием `go-to-new-note-page`. 
Переместите копию `mainPageActionButton` на элемент `Application`, тем самым заменив его.

(имаж)

За переходы между страницами отвечает функция `goToPage`. Поместите функцию в свободную область flow диаграммы.
У `mainPageActionButton` есть событие `onClick`, и вы можете это событие привязать ко входу в функции `goToPage`. 

(имаж)

Но вы, наверное, заметили, что эта функция находится в наборе функций с именем компонента `PageRouteNavigation`.
И наверное эта функция как-то должна быть связанна с данным компонентом.

Действительно, если прочитать спецификацию функции `goToPage`, то вы поймете, 
что выход функции `pageRouteAbchorProps` должен быть связан с копией компонента `PageRouteNavigation`. 

Но у нас нет копии этого компонента ни на одной странице. Это потому что мы занимались только визуальными компонентами.
Теперь настал черед добавить необходимые невидимые компоненты.

Перейдите на закладку редактора страницы `main`. Откройте структуру дерева страницы, о выберите копию `mainPageFrame`.
В редакторе свойств найдите массив `Hidden Components` и добавьте в него один item кликнув на кнопку "+1".

(имаж)

Теперь перетащите компонент `PageRouterAnchor` в свободную область `0 item` под `Hidden Components` в дереве структуры страницы.
Переименуйте копию на `newNotePageRouteAnchor` и установите значение `/new-note` в свойство `Page Route Path`.

(имаж)  

Теперь вы можете перейти на закладку редактора `go-to-new-note-page` flow диаграммы. 
Перетащите копию `newNotePageRouteAnchor` куда-то на свободное место на диаграмме. 
Соедините выход `pageRouteAbchorProps` в функции `goToPage` со входом `props` в `newNotePageRouteAnchor`.

Таким образом функция может прочитать значение свойства `Page Route Path` и перейти по указанному там адресу.

(имаж)

Можете попробовать как это работает в закладке "Live Preview".

Теперь надо создать flow диаграмму для того, 
чтобы вернуть пользователя на главную страницу если он нажал кнопку `Cancel` в форме добавления новой записи.

Но перед этим, вам необходимо добавить копию компонента `PageRouterAnchor` на страницу `new-note` для перехода на `main` страницу.

Откройте закладку редактора страницы `new-note`, добавьте item в свойство `Hidden Components` в копии `newNotePageFrame`.
Перетащите компонент `PageRouterAnchor` в новый item, и переименуйте его на `mainPageRouteAnchor`.
Установите значение "/" в свойство `Page Route Path`.

(имаж)

Создайте новую flow диаграмму с именем `cancelling-new-note`. 
Земените начальный элемент `Application` на копию `newNoteForm`.
Добавьте функцию `goToPage` в диаграмму и соедините ее вход с выходом `onCancel` копии `newNoteForm`.

> Событие `onCancel` происходит когда пользователь кликает на кнопку `Cancel` в форме `newNoteForm`

Добавьте копию `mainPageRouteAnchor` (из секции "Pages" и страницы `new-note`) в диаграмму. 
Соедините выход `pageRouteAnchorProps` в функции `goToPage` с входом `props` в копии `mainPageRouteAnchor`.

(имаж)

Можете убедиться в закладке "Live Preview", что нажатие на кнопку `Cancel` возвращает пользователя на главную страницу.

Список ToDo на главной странице все еще пустой. 
Но это поправимо, потому что у вас есть набор функций, с помощью которых можно получить список записей, отфильтровать его и сохранить.

> Эти функции вы можете найти в наборе `ToDoActions`

Насколько можно судить по описанию функций в наборе `ToDoActions`, 
вы можете загрузить все записи из базы данных и поместить их в буфер для дальнешей работы с ними через этот буфер.

Список необходимо загрузить в самом начале работы приложения. Это легко сделать в новом flow.

Создайте новую flow диаграмму с именем `load-notes-on-start`. 
Поместите функцию `getNotes` куда-нибудь в свободное место на диаграмме.
Подсоедините выход `onApplicationStart` в элементе `Application` ко входу функции `getNotes`. 
Таким образом вы указали, что необходимо загрузить список записей во время старта приложения в браузере.

(имаж)      

Загруженный список необходимо записать в буфер в памяти. Это можно сделать с помощью функции `putIntoNotesBuffer`.
Соедините выход `notes` в функции `getNotes` со входом функции `putIntoNotesBuffer`.

(имаж)

Буфер памяти вам необходим для минимизации количества вызовов функций для обновления компонента списка записей `mainPageNotesList`.

Вы можете подключить буфер к компоненту через функцию listener, 
которая будет передавать в компонент обновленные данные каждый раз когда список в буфере будет изменен.
Иначе вам бы пришлось при каждой операции со списком добавлять вызовы функций для обновления списка в копии `mainPageNotesList`.

Создайте новую flow диаграмму с именем `update-notes-by-navigation-filter`. 
Это имя выбрано из-за того, что список должен быть всегда отфильтрован по выбраному типу фильтра в копии `mainPageNavigationTabs`.

Добавьте функцию `listenToNotesBuffer` в диаграмму и соедините ее вход с выходом `onApplicationStart` в `Application` элементе.
Таким образом, вы сказали, что при запуске приложения в браузере необходимо начать следить за изменениями в буфере.

(имаж)

Теперь вам необходимо сказать что делать при изменении списка в буфере.
Добавьте функцию `filterNotes` и соедините ее вход с выходом `updatedData` в функции `listenToNotesBuffer`.
Добавьте копию `mainPageNotesList` и соедините ее вход копии с выходом `todoNotesListProps` в функции `filterNotes`.
Также добавьте копию `mainPageNavigationTabs` и соедините ее вход с выходом `navigationTabsProps` в функции `filterNotes`.

(имаж)

Вы наверное догадались, что в данном случае 
функция `filterNotes` прочитает все свойства копии `navigationTabsProps` и в зависимости от значения 
в свойстве `Active Tab Type` отфильтрует обновленный список из буфера и передаст его в свойства копии `todoNotesListProps`.   

Если это так, то вам необходимо добавить обновление списка в буфере при изменении фильтра. 
Поэтому откройте `change-navigation-filter-by-click` flow диаграмму и добавьте в нее функцию `getNotes`.
Выход `onActiveTabUpdated` в копии `mainPageNavigationTabs` (последней в цепочке) соедините с входом функции `getNotes`.
А выход `notes` в функции `getNotes` соедините с входом функции `putIntoNotesBuffer`.

(имаж)   

Если сейчас проверить как работает приложение, то мы увидим только пустой список.

(имаж)

Теперь необходимо создать flow, который позволит пользователю добавлять новые записи в список ToDo.

Создайте новую диаграмму flow с именем `adding-new-note`.
Замените `Application` на копию `newNoteForm`. 
Добавьте `validateNoteText` функцию в диаграмму. 
Соедините выход `onSaveNote` в копии `newNoteForm` с входом функции `validateNoteText`.

> Событие `onSaveNote` происходит когда пользователь кликает на кнопку `Save` в форме `newNoteForm`. 
> На выходе функция получает текст новой записи.

(имаж)

Функция `validateNoteText` проверяет переданный в нее текст, и если текст не проходит проверку, то возникает событие `failure`.
К нему вы должны подсоединить функцию `setError` из набора `NewNoteForm`. 
А выход `newNoteFormProps` в функции `setError` подключить ко входу `props` в копии `newNoteForm`.

(имаж)

В случае успешной проверки, функция `validateNoteText` передает валидный текст на выход `noteText`. 
Подсоедините выход `noteText` ко входу функции `createNewNote` из набора `ToDoActions`.
Выход `notes` в функции `createNewNote` подсоедините к входу функции `saveNotes`.  

(имаж)

Если выполнится события `success` в функции `saveNotes`, то это означает, 
что новая запись успешно была сохранена в локальную базу. 
Подсоедините к выходу `success` вход функции `goToPage`, которую в свою очередь подсоедините к копии `mainPageRouteAnchor`.

Таким образом вы создали цепочку действий для создания новой записи и сохранения ее в локальной базе данных, и переходу на главную страницу.

(имаж)

Но вам нужно еще обновить список в буфере, чтобы новый список отобразился на главной странице.
Поэтому добавьте функцию `putIntoNotesBuffer` и соедините ее вход с выходом `notes` в функции `saveNotes`. 

(имаж)

Вы можете проверить как работает добавление новой записи в закладке "Live Preview".

Осталось сделать еще одну flow диаграмму с удалением записи или изменении статуса записи в списке.
Так как это все делатся по разным событиям, которые возникают в копии `mainPageNotesList`, 
то вы можете все сделать в одной диаграмме.

Создайте flow диаграмму с именем `toggle-or-delete-note-by-user`.
Замените элемент `Application` на копию `mainPageNotesList`.
Добавьте функцию `deleteNote` и соедините ее вход с выходом `onDeleteNote` в копии `mainPageNotesList`.
Так же добавьте функцию `saveNotes` и соедините ее вход в выходом `notes` в функции `deleteNote`.
И как вы уже догадались наверное, необходимо обновить записи в буфере. 
Поэтому перетяните функцию `putIntoNotesBuffer` и соедините ее вход с выходом `notes` в функции `saveNotes`.
Ну что же, вы сделали удаление записей по клику на кнопку удаления в списке на главной странице.

(имаж)

Теперь создадим часть flow для изменения статуса записи в списке по клику на checkbox.
Добавьте функцию `toggleNodeCompleted` и соедините ее вход с выходом `onToggleNoteCompleted` в копии `mainPageNotesList`.
Затем добавьте еще один элемент функции `saveNotes` и соедините ее вход с выходом `notes` в функции `toggleNodeCompleted`.
И конечно же, необходимо передать новый список в буффер.
Перетяните функцию `putIntoNotesBuffer` и соедините ее вход с выходом `notes` в функции `saveNotes`.

(имаж)

Теперь ваше приложение имеет полностью реализованный функционал. Проверьте это в "Live Preview". 
Вы также можете открыть приложение в отдельном окне кликнув на кнопку `Open URL` на top toolbar в "Live Preview".

### Design System

В проектах Webcodesk есть возможность задавать глобальные свойства всего приложения. 
Так как в данном проекте используется библиотека Material UI, которая позволяет создавать разные темы для компонентов, 
то в проект была добавлена возможность менять настройки темы.

Откройте закладку "Live Preview" и кликните на кнопку `Settings` на top toolbar. 
Вы увидите панель свойств похожую на панель свойств в редакторе страницы. 

В проекте для примера была реализована самая малая часть Design System настроек для темы Material UI.

> Как добавляются глобальные настройки в код проекта читайте в User Guide (линк).

Поэтому вы можете тут изменить только цвета, которые используются в компонентах.
Измените значение свойства `Theme` -> `Palette` -> `Primary` -> `Main` -> `Color Hue` на "orange" и нажмите кнопку `Save Changes` вверху панели.

(имаж)

### Debug data flow

Кроме того, что вы можете отлаживать приложение с помощью инструментов встроенных в браузер, 
Webcodesk предоставляет возможность визуализировать прохождение данных по элементам flow.

Откройте закладку "Live Preview", и кликните на кнопку `Record Actions`. 
Она должна сменить свое название на `Stop Recording`.

Теперь покликайте, например, по кнопкам фильтра: `Active` -> `Completed` -> `All`. 
И после этого кликните на `Stop Recording`.
Вы увидите большую составленную flow диаграмму из всех диаграм, которые вы создавали. 
На ней будут отмечены цветом только элементы, через которые проходил поток данных.    

(имаж)


---